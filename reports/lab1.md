# LAB1实验报告

## 编程实验
### 实验要求分析
**实验要求**：完成获取 task info 的系统调用  
**要求分析**：需要实现系统调用，在进程信息中维护启动时间和系统调用次数并在系统调用中获取对应内容

### 实现方法
1. 在 task 中找到维护系统进程信息的类型，在其中加入启动时间和系统调用次数条目
2. 在运行进程时检查运行时间是否为默认值，若是则设置启动时间为当前时间
3. 添加获取这部分信息和增加系统调用的接口函数
4. 在系统调用的函数中调用增加系统调用的函数
5. 在对应的 syscall 里获取进程信息并返回数据

## 简答题答案
1. RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0, Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2
- **bad address:** 写0地址（被视为空指针）导致发生缺页异常
- **bad instructions:** 在用户态使用特权指令 sret 导致发生 IllegalInstruction 异常
- **bad register:** 对状态寄存器 sstatus 的操作是特权级操作，无法在用户态中完成，产生 IllegalInstruction 异常
2.   
- **1:** 是 trap_handler 的返回值，即将要恢复的栈帧。该栈帧与 __alltraps 传入的栈帧相比其 a0 是 syscall 的返回值，同时 pc 增长了4。  
__restore 的使用场景：在 trap_handler 返回后恢复原用户态的栈帧，在进程执行前切换栈帧，进入用户态。
- **2:** 特殊处理了 sstatus, sepc, sscratch 寄存器。 sepc 寄存器为 sret 后 pc 寄存器的值，设置了用户态中继续执行的位置； sstatus 寄存器保存了 sret 后的状态信息， sret 后特权模式设为 sstatus.SPP ，将 sstatus.SIE 设为 sstatus.SPIE ，将 sstatus.SPIE 设为1，将 sstatus.SPP 设为0，设置了用户态中的特权模式和中断使能位； sscratch 寄存器保存了用户栈和内核栈的栈指针，用于在之后发生 trap 时切换到内核栈。
- **3:** 因为 x2 是 sp, 在这里 sp 还用于指向内核栈的栈顶，此时栈顶保存了原用户态的寄存器信息，需要在恢复其他寄存器后再从 sscratch 中恢复； x4 是 tp, 用户不使用这个寄存器。
- **4:** sp 指向了原用户栈栈顶， sscratch 指向了内核栈栈顶。
- **5:** L61 的 sret. 因为这会恢复将特权模式设为 sstatus.SPP , 而在 trap 发生之前的特权模式为用户态，S模式响应异常时会将当前的特权模式保存在 sstatus.SPP 中，并将特权模式设为 S.
- **6:** sp 指向了上一次进入用户态前保存的内核栈栈顶， sscratch 指向当前用户栈的栈顶。
- **7:** 在用户执行 ecall 指令或发生其他产生异常的指令中发生。
## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> The RISC-V Instruction Set Manual Volume II: Privileged Architecture  
> RISC-V 开放架构设计之道1.0.0

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。